import { jsPDF } from "jspdf";
import { QRCodeCanvas } from "qrcode.react";

// Log global para verificar se o arquivo estÃ¡ sendo carregado
console.log('ðŸ”¥ðŸ”¥ðŸ”¥ ARQUIVO certificatePDFGenerator.js CARREGADO!', new Date().toISOString());

/**
 * FunÃ§Ã£o utilitÃ¡ria para calcular quebras de linha e espaÃ§amento
 * @param {Object} doc - InstÃ¢ncia do jsPDF
 * @param {string} text - Texto a ser analisado
 * @param {number} maxWidth - Largura mÃ¡xima em pixels
 * @param {number} fontSize - Tamanho da fonte
 * @returns {Object} - { linesCount, extraSpacing }
 */
function calculateTextLines(doc, text, maxWidth = 700, fontSize = 16) {
  const textWidth = doc.getTextWidth(text);
  let actualLinesCount = 1;

  if (textWidth > maxWidth) {
    const words = text.split(' ');
    let currentLineWidth = 0;
    actualLinesCount = 1;

    words.forEach(word => {
      const wordWidth = doc.getTextWidth(word + ' ');
      if (currentLineWidth + wordWidth > maxWidth && currentLineWidth > 0) {
        actualLinesCount++;
        currentLineWidth = wordWidth;
      } else {
        currentLineWidth += wordWidth;
      }
    });
  }

  const lineHeight = fontSize;
  const extraSpacing = actualLinesCount > 1 ? (actualLinesCount - 1) * lineHeight : 0;

  return {
    linesCount: actualLinesCount,
    extraSpacing
  };
}

/**
 * FunÃ§Ã£o utilitÃ¡ria para gerar PDF de certificado
 * @param {Object} certificateData - Dados completos do certificado
 * @param {string} certificadoImageSrc - Caminho para a imagem do certificado
 * @returns {Promise<void>} - Gera e faz download do PDF
 */
export async function generateCertificatePDF(certificateData, certificadoImageSrc = '/images/certificatesbg/certificado.png') {
  try {
    // Log com timestamp para verificar se estÃ¡ executando a versÃ£o mais nova
    const timestamp = new Date().toISOString();
    console.log(`ðŸ”¥ðŸ”¥ðŸ”¥ FUNÃ‡ÃƒO generateCertificatePDF EXECUTADA EM: ${timestamp}`);

    // Debug visÃ­vel para garantir que a funÃ§Ã£o estÃ¡ sendo chamada
    console.log('ðŸ”¥ INÃCIO generateCertificatePDF - TESTE DE DEBUG');
    console.log('ðŸ“„ certificateData completo:', JSON.stringify(certificateData, null, 2));
    console.log('ðŸ” certificateData.certType:', certificateData.certType);
    console.log('ðŸ” typeof certificateData.certType:', typeof certificateData.certType);
    console.log('ðŸ” ComparaÃ§Ã£o PRESENTATION:', certificateData.certType === 'PRESENTATION');

    // Alert para debug visÃ­vel
    alert(`ðŸ”¥ FUNÃ‡ÃƒO EXECUTADA EM: ${timestamp}\nCertType: ${certificateData.certType}`);
    if (certificateData.certType === 'PRESENTATION') {
      alert('ðŸ”¥ DEBUG: Certificado de APRESENTAÃ‡ÃƒO detectado! Primeira linha deve ser normal.');
    }
  } catch (earlyError) {
    console.error('ðŸ”´ ERRO NO INÃCIO DA FUNÃ‡ÃƒO:', earlyError);
    alert('ðŸ”´ ERRO NO INÃCIO DA FUNÃ‡ÃƒO: ' + earlyError.message);
  }

  return new Promise(async (resolve, reject) => {
    try {
      console.log('ðŸ” CHECKPOINT 1: Iniciando Promise...');
      
      const doc = new jsPDF({ orientation: "landscape", unit: "px", format: [842, 595] });
      
      // Dados do certificado
      const processedLines = certificateData?.processedLines || [];
      const participantName = certificateData?.user?.name || 'Nome nÃ£o informado';
      const code = certificateData?.code || '';
      const templateTitle = certificateData?.template?.title || 'Certificado';
      const userType = certificateData?.userType || '';
      const certType = certificateData?.certType || '';

      console.log('ðŸ” CHECKPOINT 2: Dados extraÃ­dos...');

      // FunÃ§Ã£o para identificar linha com nome
      const isNameLine = (line, index) => {
        const nameToCheck = participantName.toLowerCase();
        return line.toLowerCase().includes(nameToCheck) || (index === 1 && processedLines.length > 1);
      };

      // FunÃ§Ã£o para obter linhas de exibiÃ§Ã£o
      const getDisplayLines = () => {
        if (processedLines.length === 0) {
          return [
            "Certificamos que",
            participantName,
            "participou da XI Jornada Mineira de Radiologia (JMR2025) e do XIV Congresso de Imaginologia da Mulher (CIM2025)",
            "evento realizado nos dias 27 e 28 de junho de 2025",
            "no Centro de ConvenÃ§Ãµes da AssociaÃ§Ã£o MÃ©dica de Minas Gerais (AMMG), em Belo Horizonte/MG, Brasil",
            "Carga horÃ¡ria total: 20 horas"
          ];
        }
        return processedLines;
      };

      // Criar QR Code URL
      const qrUrl = `${window?.location?.origin || ''}/certificate?codigo=${code}`;
      console.log('ðŸ” CHECKPOINT 3: QR URL criado:', qrUrl);

      // FunÃ§Ã£o para gerar QR Code usando QRCodeCanvas do qrcode.react
      const generateQRCode = async (url, size = 120) => {
        try {
          console.log('ðŸ” CHECKPOINT 4: Gerando QR Code...');
          
          // Importar React e createRoot uma vez
          const { createElement } = await import('react');
          const { createRoot } = await import('react-dom/client');

          // Criar um container temporÃ¡rio
          const container = document.createElement('div');
          container.style.position = 'absolute';
          container.style.left = '-9999px';
          document.body.appendChild(container);

          return new Promise((resolve, reject) => {
            try {
              const qrElement = createElement(QRCodeCanvas, {
                value: url,
                size: size,
                level: 'M',
                includeMargin: false
              });

              const root = createRoot(container);
              root.render(qrElement);

              // Aguardar um pouco para o canvas ser renderizado
              setTimeout(() => {
                const canvas = container.querySelector('canvas');
                if (canvas) {
                  const dataUrl = canvas.toDataURL("image/png");
                  document.body.removeChild(container);
                  console.log('ðŸ” CHECKPOINT 5: QR Code gerado com sucesso');
                  resolve(dataUrl);
                } else {
                  document.body.removeChild(container);
                  reject(new Error('Canvas nÃ£o encontrado'));
                }
              }, 300);

              // Timeout de seguranÃ§a
              setTimeout(() => {
                if (document.body.contains(container)) {
                  document.body.removeChild(container);
                  reject(new Error('Timeout na geraÃ§Ã£o do QR Code'));
                }
              }, 5000);

            } catch (error) {
              if (document.body.contains(container)) {
                document.body.removeChild(container);
              }
              reject(error);
            }
          });
        } catch (error) {
          console.error('Erro ao gerar QR Code:', error);
          throw error;
        }
      };

      try {
        // Gerar QR Code
        const qrDataUrl = await generateQRCode(qrUrl, 120);
        console.log('ðŸ” CHECKPOINT 6: QR Code obtido, carregando imagem...');

        // Carregar imagem do certificado
        const img = new window.Image();
        img.crossOrigin = 'anonymous';
        img.src = certificadoImageSrc;

        img.onload = () => {
          try {
            console.log('ðŸ” CHECKPOINT 7: Imagem carregada, gerando PDF...');
            
            // Primeira pÃ¡gina - certificado com template
            doc.addImage(img, "PNG", 0, 0, 842, 595);

            const textLines = getDisplayLines();
            let currentY = 180;
            const centerX = 421;

            console.log('ðŸ” CHECKPOINT 8: Processando linhas do certificado...');
            console.log('ðŸ” textLines:', textLines);

            // Processar cada linha do template
            textLines.forEach((line, index) => {
              if (!line || line.trim() === '') return;
              
              console.log(`ðŸ” CHECKPOINT 9.${index}: Processando linha ${index}: "${line}"`);
              
              // Definir estilos baseado no contexto da linha
              let fontSize, fontWeight, baseSpacing;
              if (index === 0) {
                // Primeira linha - geralmente "Certificamos que"
                fontWeight = certificateData.certType === 'PRESENTATION'? "normal": "bold";

                // Logs para debug no console do browser
                console.log('ðŸ”¥ DEBUG CERTIFICADO:');
                console.log('certType:', certificateData.certType);
                console.log('Ã‰ PRESENTATION?:', certificateData.certType === 'PRESENTATION');
                console.log('fontWeight calculado:', fontWeight);
                console.log('Linha de texto:', line);

                // Aplicar fonte usando mÃ©todo mais direto
                if (certificateData.certType === 'PRESENTATION') {
                  // Para apresentaÃ§Ã£o: fonte normal
                  doc.setFont("times", "normal");
                  console.log('âœ… Aplicou Times Normal');
                } else {
                  // Para outros: fonte bold
                  doc.setFont("times", "bold");
                  console.log('âœ… Aplicou Times Bold');
                }

                fontSize = certificateData.certType === 'PRESENTATION'? 18: 22;
                doc.setFontSize(fontSize);
                baseSpacing = certificateData.certType === 'PRESENTATION'? Math.round(18 * 1.1): 30;
                currentY += baseSpacing;
              } else if (isNameLine(line, index)) {
                // Linha com o nome da pessoa
                doc.setFont("Times", "bold");
                fontSize = certificateData.certType === 'PRESENTATION'? 18: 28;
                doc.setFontSize(fontSize);
                fontWeight = "bold";
                baseSpacing = certificateData.certType === 'PRESENTATION'? Math.round(18 * 1.1): 35;
                currentY += baseSpacing;
              } else {
                // Linhas de conteÃºdo (aumento de 10% no espaÃ§amento)
                doc.setFont("Times", "normal");
                fontSize = 18;
                doc.setFontSize(fontSize);
                fontWeight = "normal";
                baseSpacing = Math.round(18 * 1.1); // Aumento de 10%
                currentY += baseSpacing;
              }

              // Calcular quantas linhas o texto irÃ¡ ocupar
              const maxWidth = 700;
              const { linesCount, extraSpacing } = calculateTextLines(doc, line, maxWidth, fontSize);

              // Se o texto nÃ£o quebra, renderizar normalmente
              if (linesCount === 1) {
                console.log('ðŸ“ Renderizando linha:', index, 'texto:', line, 'fontWeight atual:', fontWeight);
                doc.text(line, centerX, currentY, {
                  align: "center",
                  maxWidth: maxWidth
                });
              } else {
                // Se o texto quebra em mÃºltiplas linhas, renderizar linha por linha com espaÃ§amento
                const words = line.split(' ');
                let currentLineText = '';
                let lineIndex = 0;
                const lineSpacing = fontSize * 1.22; // 22% a mais entre linhas quebradas

                words.forEach((word, wordIndex) => {
                  const testLine = currentLineText ? `${currentLineText} ${word}` : word;
                  const testWidth = doc.getTextWidth(testLine);

                  if (testWidth > maxWidth && currentLineText) {
                    // Renderizar a linha atual
                    doc.text(currentLineText, centerX, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                    lineIndex++;
                    currentLineText = word;
                  } else {
                    currentLineText = testLine;
                  }

                  // Se Ã© a Ãºltima palavra, renderizar a linha final
                  if (wordIndex === words.length - 1) {
                    doc.text(currentLineText, centerX, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                  }
                });

                // Ajustar currentY para as linhas adicionais
                currentY += (linesCount - 1) * lineSpacing;
              }

              // Adicionar espaÃ§o extra apÃ³s a linha do nome
              if (isNameLine(line, index)) {
                currentY += 15; // EspaÃ§o extra apÃ³s o nome
              }
            });

            console.log('ðŸ” CHECKPOINT 10: Linhas processadas, finalizando PDF...');

            // CÃ³digo de autenticaÃ§Ã£o
            currentY += 40;
            doc.setFont("Times", "normal");
            doc.setFontSize(12);
            doc.text(`CÃ³digo de autenticaÃ§Ã£o: ${code}`, centerX, currentY, { align: "center" });

            // QR Code pequeno no canto
            doc.addImage(qrDataUrl, 'PNG', 727, 150, 50, 50);

            // Segunda pÃ¡gina (fundo branco)
            doc.addPage([842, 595], 'landscape');
            let y = 120;

            // TÃ­tulo da segunda pÃ¡gina
            doc.setFont("Times", "bold");
            doc.setFontSize(22);
            doc.text("QR Code para ValidaÃ§Ã£o", centerX, y, { align: "center" });
            y += 40;

            // QR Code grande centralizado
            doc.addImage(qrDataUrl, 'PNG', 371, y, 100, 100);
            y += 120;

            // InformaÃ§Ãµes do certificado
            doc.setFont("Times", "bold");
            doc.setFontSize(16);
            doc.text(`Tipo: ${templateTitle}`, centerX, y, { align: "center" });
            y += 25;

            doc.setFont("Times", "normal");
            doc.setFontSize(14);
            doc.text(`Modalidade: ${userType} - ${certType}`, centerX, y, { align: "center" });
            y += 25;

            // CÃ³digo de autenticaÃ§Ã£o
            doc.setFontSize(16);
            doc.text(`CÃ³digo de autenticaÃ§Ã£o: ${code}`, centerX, y, { align: "center" });
            y += 30;

            // Link para validaÃ§Ã£o
            doc.setFontSize(14);
            doc.text(`Valide em: ${qrUrl}`, centerX, y, { align: "center", maxWidth: 700 });
            y += 50;

            // NOTA LEGAL
            doc.setFontSize(18);
            doc.setFont("Times", "bold");
            doc.text("NOTA LEGAL:", centerX, y, { align: "center" });
            y += 30;

            doc.setFontSize(12);
            doc.setFont("Times", "normal");
            const notaLegal = [
              "O certificado Ã© um documento de comprovaÃ§Ã£o da sua atividade cientÃ­fica no evento. Sua adulteraÃ§Ã£o e uso indevido Ã© ilegal e estÃ¡ sujeita Ã s penas da lei.",
              "",
              "Decreto Lei nÂº 2.848 de 07 de Dezembro de 1940",
              "",
              "Art. 299 - Omitir, em documento pÃºblico ou particular, declaraÃ§Ã£o que dele devia constar, ou nele inserir ou fazer inserir declaraÃ§Ã£o falsa ou diversa da que devia ser escrita, com o fim de prejudicar direito, criar obrigaÃ§Ã£o ou alterar a verdade sobre fato juridicamente relevante:",
              "",
              "Pena - reclusÃ£o, de um a cinco anos, e multa, se o documento Ã© pÃºblico, e reclusÃ£o de um a trÃªs anos, e multa, se o documento Ã© particular.",
              "",
              "ParÃ¡grafo Ãºnico - Se o agente Ã© funcionÃ¡rio pÃºblico, e comete o crime prevalecendo-se do cargo, ou se a falsificaÃ§Ã£o ou alteraÃ§Ã£o Ã© de assentamento de registro civil, aumenta-se a pena de sexta parte."
            ];

            notaLegal.forEach((line, i) => {
              if (line.trim() === "") {
                return;
              }
              doc.text(line, centerX, y + i * 15, { align: "center", maxWidth: 700 });
            });

            console.log('ðŸ” CHECKPOINT 11: Salvando arquivo PDF...');

            // Nome do arquivo baseado no template e participante
            const safeName = participantName.replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
            const templateName = certificateData?.template?.metadata?.template || certType || 'certificado';
            const fileName = `${templateName}-${safeName}-${code}.pdf`;

            // Salvar arquivo
            doc.save(fileName);
            
            console.log('ðŸ” CHECKPOINT 12: PDF salvo com sucesso!');
            alert('ðŸŽ‰ PDF gerado com sucesso!');
            
            resolve();

          } catch (error) {
            console.error('ðŸ”´ Erro ao processar imagem e gerar PDF:', error);
            alert('ðŸ”´ Erro ao processar imagem: ' + error.message);
            reject(error);
          }
        };

        img.onerror = () => {
          console.warn('âš ï¸ NÃ£o foi possÃ­vel carregar a imagem do certificado, gerando PDF apenas com texto');
          alert('âš ï¸ Imagem nÃ£o carregou, gerando PDF simples...');
          
          try {
            // Se nÃ£o conseguir carregar a imagem, gerar PDF sem ela
            // Gerar PDF apenas com texto
            doc.setFont("Times", "bold");
            doc.setFontSize(24);
            doc.text(templateTitle, 421, 100, { align: "center" });

            const textLines = getDisplayLines();
            let currentY = 150;

            textLines.forEach((line, index) => {
              if (!line || line.trim() === '') return;

              // Definir estilos e espaÃ§amento baseado no contexto da linha
              let fontSize, baseSpacing, fontWeight;
              if (index === 0) {
                fontWeight = certificateData.certType === 'PRESENTATION'? "normal": "bold";
                console.log('ðŸ”¤ img.onerror - certType:', certificateData.certType, 'fontWeight:', fontWeight);

                // Aplicar fonte usando mÃ©todo mais direto
                if (certificateData.certType === 'PRESENTATION') {
                  doc.setFont("times", "normal");
                } else {
                  doc.setFont("times", "bold");
                }

                fontSize = certificateData.certType === 'PRESENTATION'? 18: 22;
                doc.setFontSize(fontSize);
                baseSpacing = certificateData.certType === 'PRESENTATION'? Math.round(18 * 1.1): 30;
                currentY += baseSpacing;
              } else if (isNameLine(line, index)) {
                doc.setFont("Times", "bold");
                fontSize = 20;
                doc.setFontSize(fontSize);
                baseSpacing = 30;
                currentY += baseSpacing;
              } else {
                doc.setFont("Times", "normal");
                fontSize = 16;
                doc.setFontSize(fontSize);
                baseSpacing = Math.round(16 * 1.1); // Aumento de 10%
                currentY += baseSpacing;
              }

              // Calcular quebras de linha para ajustar espaÃ§amento
              const maxWidth = 700;
              const { linesCount, extraSpacing } = calculateTextLines(doc, line, maxWidth, fontSize);

              // Se o texto nÃ£o quebra, renderizar normalmente
              if (linesCount === 1) {
                doc.text(line, 421, currentY, { align: "center", maxWidth: 700 });
              } else {
                // Se o texto quebra em mÃºltiplas linhas, renderizar linha por linha com espaÃ§amento
                const words = line.split(' ');
                let currentLineText = '';
                let lineIndex = 0;
                const lineSpacing = fontSize * 1.22; // 22% a mais entre linhas quebradas

                words.forEach((word, wordIndex) => {
                  const testLine = currentLineText ? `${currentLineText} ${word}` : word;
                  const testWidth = doc.getTextWidth(testLine);

                  if (testWidth > maxWidth && currentLineText) {
                    // Renderizar a linha atual
                    doc.text(currentLineText, 421, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                    lineIndex++;
                    currentLineText = word;
                  } else {
                    currentLineText = testLine;
                  }

                  // Se Ã© a Ãºltima palavra, renderizar a linha final
                  if (wordIndex === words.length - 1) {
                    doc.text(currentLineText, 421, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                  }
                });

                // Ajustar currentY para as linhas adicionais
                currentY += (linesCount - 1) * lineSpacing;
              }

              // Adicionar espaÃ§o extra apÃ³s a linha do nome
              if (isNameLine(line, index)) {
                currentY += 20; // EspaÃ§o extra apÃ³s o nome
              }
            });

            currentY += 50;
            doc.setFont("Times", "normal");
            doc.setFontSize(12);
            doc.text(`CÃ³digo de autenticaÃ§Ã£o: ${code}`, 421, currentY, { align: "center" });

            // Adicionar QR Code mesmo sem imagem de fundo
            doc.addImage(qrDataUrl, 'PNG', 371, currentY + 30, 100, 100);

            const safeName = participantName.replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
            const templateName = certificateData?.template?.metadata?.template || certType || 'certificado';
            const fileName = `${templateName}-${safeName}-${code}.pdf`;

            doc.save(fileName);
            alert('ðŸŽ‰ PDF simples gerado com sucesso!');
            resolve();

          } catch (error) {
            console.error('ðŸ”´ Erro ao gerar PDF sem imagem:', error);
            alert('ðŸ”´ Erro ao gerar PDF sem imagem: ' + error.message);
            reject(error);
          }
        };
      } catch (qrError) {
        console.error('ðŸ”´ Erro ao gerar QR Code:', qrError);
        alert('ðŸ”´ Erro ao gerar QR Code: ' + qrError.message);
        reject(qrError);
      }
    } catch (error) {
      console.error('ðŸ”´ Erro geral na funÃ§Ã£o:', error);
      alert('ðŸ”´ Erro geral: ' + error.message);
      reject(error);
    }
  });
}
