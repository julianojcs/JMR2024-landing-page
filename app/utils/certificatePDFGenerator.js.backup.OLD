import { jsPDF } from "jspdf";
import { QRCodeCanvas } from "qrcode.react";

// Log global para verificar se o arquivo est√° sendo carregado
console.log('üî•üî•üî• ARQUIVO certificatePDFGenerator.js CARREGADO!', new Date().toISOString());

/**
 * Fun√ß√£o utilit√°ria para calcular quebras de linha e espa√ßamento
 * @param {Object} doc - Inst√¢ncia do jsPDF
 * @param {string} text - Texto a ser analisado
 * @param {number} maxWidth - Largura m√°xima em pixels
 * @param {number} fontSize - Tamanho da fonte
 * @returns {Object} - { linesCount, extraSpacing }
 */
function calculateTextLines(doc, text, maxWidth = 700, fontSize = 16) {
  const textWidth = doc.getTextWidth(text);
  let actualLinesCount = 1;

  if (textWidth > maxWidth) {
    const words = text.split(' ');
    let currentLineWidth = 0;
    actualLinesCount = 1;

    words.forEach(word => {
      const wordWidth = doc.getTextWidth(word + ' ');
      if (currentLineWidth + wordWidth > maxWidth && currentLineWidth > 0) {
        actualLinesCount++;
        currentLineWidth = wordWidth;
      } else {
        currentLineWidth += wordWidth;
      }
    });
  }

  const lineHeight = fontSize;
  const extraSpacing = actualLinesCount > 1 ? (actualLinesCount - 1) * lineHeight : 0;

  return {
    linesCount: actualLinesCount,
    extraSpacing
  };
}

/**
 * Fun√ß√£o utilit√°ria para gerar PDF de certificado
 * @param {Object} certificateData - Dados completos do certificado
 * @param {string} certificadoImageSrc - Caminho para a imagem do certificado
 * @returns {Promise<void>} - Gera e faz download do PDF
 */
export async function generateCertificatePDF(certificateData, certificadoImageSrc = '/images/certificatesbg/certificado.png') {
  try {
    // Log com timestamp para verificar se est√° executando a vers√£o mais nova
    const timestamp = new Date().toISOString();
    console.log(`üî•üî•üî• FUN√á√ÉO generateCertificatePDF EXECUTADA EM: ${timestamp}`);

    // Debug vis√≠vel para garantir que a fun√ß√£o est√° sendo chamada
    console.log('üî• IN√çCIO generateCertificatePDF - TESTE DE DEBUG');
    console.log('üìÑ certificateData completo:', JSON.stringify(certificateData, null, 2));
    console.log('üîç certificateData.certType:', certificateData.certType);
    console.log('üîç typeof certificateData.certType:', typeof certificateData.certType);
    console.log('üîç Compara√ß√£o PRESENTATION:', certificateData.certType === 'PRESENTATION');

    // Alert para debug vis√≠vel
    alert(`üî• FUN√á√ÉO EXECUTADA EM: ${timestamp}\nCertType: ${certificateData.certType}`);
    if (certificateData.certType === 'PRESENTATION') {
      alert('üî• DEBUG: Certificado de APRESENTA√á√ÉO detectado! Primeira linha deve ser normal.');
    }
  } catch (earlyError) {
    console.error('üî¥ ERRO NO IN√çCIO DA FUN√á√ÉO:', earlyError);
    alert('üî¥ ERRO NO IN√çCIO DA FUN√á√ÉO: ' + earlyError.message);
  }

  return new Promise(async (resolve, reject) => {
    try {
      console.log('üîç CHECKPOINT 1: Iniciando Promise...');
      
      const doc = new jsPDF({ orientation: "landscape", unit: "px", format: [842, 595] });
      
      // Dados do certificado
      const processedLines = certificateData?.processedLines || [];
      const participantName = certificateData?.user?.name || 'Nome n√£o informado';
      const code = certificateData?.code || '';
      const templateTitle = certificateData?.template?.title || 'Certificado';
      const userType = certificateData?.userType || '';
      const certType = certificateData?.certType || '';

      console.log('üîç CHECKPOINT 2: Dados extra√≠dos...');

      // Fun√ß√£o para identificar linha com nome
      const isNameLine = (line, index) => {
        const nameToCheck = participantName.toLowerCase();
        return line.toLowerCase().includes(nameToCheck) || (index === 1 && processedLines.length > 1);
      };

      // Fun√ß√£o para obter linhas de exibi√ß√£o
      const getDisplayLines = () => {
        if (processedLines.length === 0) {
          return [
            "Certificamos que",
            participantName,
            "participou da XI Jornada Mineira de Radiologia (JMR2025) e do XIV Congresso de Imaginologia da Mulher (CIM2025)",
            "evento realizado nos dias 27 e 28 de junho de 2025",
            "no Centro de Conven√ß√µes da Associa√ß√£o M√©dica de Minas Gerais (AMMG), em Belo Horizonte/MG, Brasil",
            "Carga hor√°ria total: 20 horas"
          ];
        }
        return processedLines;
      };

      // Criar QR Code URL
      const qrUrl = `${window?.location?.origin || ''}/certificate?codigo=${code}`;
      console.log('üîç CHECKPOINT 3: QR URL criado:', qrUrl);

      // Fun√ß√£o para gerar QR Code usando QRCodeCanvas do qrcode.react
      const generateQRCode = async (url, size = 120) => {
        try {
          console.log('üîç CHECKPOINT 4: Gerando QR Code...');
          
          // Importar React e createRoot uma vez
          const { createElement } = await import('react');
          const { createRoot } = await import('react-dom/client');

          // Criar um container tempor√°rio
          const container = document.createElement('div');
          container.style.position = 'absolute';
          container.style.left = '-9999px';
          document.body.appendChild(container);

          return new Promise((resolve, reject) => {
            try {
              const qrElement = createElement(QRCodeCanvas, {
                value: url,
                size: size,
                level: 'M',
                includeMargin: false
              });

              const root = createRoot(container);
              root.render(qrElement);

              // Aguardar um pouco para o canvas ser renderizado
              setTimeout(() => {
                const canvas = container.querySelector('canvas');
                if (canvas) {
                  const dataUrl = canvas.toDataURL("image/png");
                  document.body.removeChild(container);
                  console.log('üîç CHECKPOINT 5: QR Code gerado com sucesso');
                  resolve(dataUrl);
                } else {
                  document.body.removeChild(container);
                  reject(new Error('Canvas n√£o encontrado'));
                }
              }, 300);

              // Timeout de seguran√ßa
              setTimeout(() => {
                if (document.body.contains(container)) {
                  document.body.removeChild(container);
                  reject(new Error('Timeout na gera√ß√£o do QR Code'));
                }
              }, 5000);

            } catch (error) {
              if (document.body.contains(container)) {
                document.body.removeChild(container);
              }
              reject(error);
            }
          });
        } catch (error) {
          console.error('Erro ao gerar QR Code:', error);
          throw error;
        }
      };

      try {
        // Gerar QR Code
        const qrDataUrl = await generateQRCode(qrUrl, 120);
        console.log('üîç CHECKPOINT 6: QR Code obtido, carregando imagem...');

        // Carregar imagem do certificado
        const img = new window.Image();
        img.crossOrigin = 'anonymous';
        img.src = certificadoImageSrc;

        img.onload = () => {
          try {
            console.log('üîç CHECKPOINT 7: Imagem carregada, gerando PDF...');
            
            // Primeira p√°gina - certificado com template
            doc.addImage(img, "PNG", 0, 0, 842, 595);

            const textLines = getDisplayLines();
            let currentY = 180;
            const centerX = 421;

            console.log('üîç CHECKPOINT 8: Processando linhas do certificado...');
            console.log('üîç textLines:', textLines);

            // Processar cada linha do template
            textLines.forEach((line, index) => {
              if (!line || line.trim() === '') return;
              
              console.log(`üîç CHECKPOINT 9.${index}: Processando linha ${index}: "${line}"`);
              
              // Definir estilos baseado no contexto da linha
              let fontSize, fontWeight, baseSpacing;
              if (index === 0) {
                // Primeira linha - geralmente "Certificamos que"
                fontWeight = certificateData.certType === 'PRESENTATION'? "normal": "bold";

                // Logs para debug no console do browser
                console.log('üî• DEBUG CERTIFICADO:');
                console.log('certType:', certificateData.certType);
                console.log('√â PRESENTATION?:', certificateData.certType === 'PRESENTATION');
                console.log('fontWeight calculado:', fontWeight);
                console.log('Linha de texto:', line);

                // Aplicar fonte usando m√©todo mais direto
                if (certificateData.certType === 'PRESENTATION') {
                  // Para apresenta√ß√£o: fonte normal
                  doc.setFont("times", "normal");
                  console.log('‚úÖ Aplicou Times Normal');
                } else {
                  // Para outros: fonte bold
                  doc.setFont("times", "bold");
                  console.log('‚úÖ Aplicou Times Bold');
                }

                fontSize = certificateData.certType === 'PRESENTATION'? 18: 22;
                doc.setFontSize(fontSize);
                baseSpacing = certificateData.certType === 'PRESENTATION'? Math.round(18 * 1.1): 30;
                currentY += baseSpacing;
              } else if (isNameLine(line, index)) {
                // Linha com o nome da pessoa
                doc.setFont("Times", "bold");
                fontSize = certificateData.certType === 'PRESENTATION'? 18: 28;
                doc.setFontSize(fontSize);
                fontWeight = "bold";
                baseSpacing = certificateData.certType === 'PRESENTATION'? Math.round(18 * 1.1): 35;
                currentY += baseSpacing;
              } else {
                // Linhas de conte√∫do (aumento de 10% no espa√ßamento)
                doc.setFont("Times", "normal");
                fontSize = 18;
                doc.setFontSize(fontSize);
                fontWeight = "normal";
                baseSpacing = Math.round(18 * 1.1); // Aumento de 10%
                currentY += baseSpacing;
              }

              // Calcular quantas linhas o texto ir√° ocupar
              const maxWidth = 700;
              const { linesCount, extraSpacing } = calculateTextLines(doc, line, maxWidth, fontSize);

              // Se o texto n√£o quebra, renderizar normalmente
              if (linesCount === 1) {
                console.log('üìù Renderizando linha:', index, 'texto:', line, 'fontWeight atual:', fontWeight);
                doc.text(line, centerX, currentY, {
                  align: "center",
                  maxWidth: maxWidth
                });
              } else {
                // Se o texto quebra em m√∫ltiplas linhas, renderizar linha por linha com espa√ßamento
                const words = line.split(' ');
                let currentLineText = '';
                let lineIndex = 0;
                const lineSpacing = fontSize * 1.22; // 22% a mais entre linhas quebradas

                words.forEach((word, wordIndex) => {
                  const testLine = currentLineText ? `${currentLineText} ${word}` : word;
                  const testWidth = doc.getTextWidth(testLine);

                  if (testWidth > maxWidth && currentLineText) {
                    // Renderizar a linha atual
                    doc.text(currentLineText, centerX, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                    lineIndex++;
                    currentLineText = word;
                  } else {
                    currentLineText = testLine;
                  }

                  // Se √© a √∫ltima palavra, renderizar a linha final
                  if (wordIndex === words.length - 1) {
                    doc.text(currentLineText, centerX, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                  }
                });

                // Ajustar currentY para as linhas adicionais
                currentY += (linesCount - 1) * lineSpacing;
              }

              // Adicionar espa√ßo extra ap√≥s a linha do nome
              if (isNameLine(line, index)) {
                currentY += 15; // Espa√ßo extra ap√≥s o nome
              }
            });

            console.log('üîç CHECKPOINT 10: Linhas processadas, finalizando PDF...');

            // C√≥digo de autentica√ß√£o
            currentY += 40;
            doc.setFont("Times", "normal");
            doc.setFontSize(12);
            doc.text(`C√≥digo de autentica√ß√£o: ${code}`, centerX, currentY, { align: "center" });

            // QR Code pequeno no canto
            doc.addImage(qrDataUrl, 'PNG', 727, 150, 50, 50);

            // Segunda p√°gina (fundo branco)
            doc.addPage([842, 595], 'landscape');
            let y = 120;

            // T√≠tulo da segunda p√°gina
            doc.setFont("Times", "bold");
            doc.setFontSize(22);
            doc.text("QR Code para Valida√ß√£o", centerX, y, { align: "center" });
            y += 40;

            // QR Code grande centralizado
            doc.addImage(qrDataUrl, 'PNG', 371, y, 100, 100);
            y += 120;

            // Informa√ß√µes do certificado
            doc.setFont("Times", "bold");
            doc.setFontSize(16);
            doc.text(`Tipo: ${templateTitle}`, centerX, y, { align: "center" });
            y += 25;

            doc.setFont("Times", "normal");
            doc.setFontSize(14);
            doc.text(`Modalidade: ${userType} - ${certType}`, centerX, y, { align: "center" });
            y += 25;

            // C√≥digo de autentica√ß√£o
            doc.setFontSize(16);
            doc.text(`C√≥digo de autentica√ß√£o: ${code}`, centerX, y, { align: "center" });
            y += 30;

            // Link para valida√ß√£o
            doc.setFontSize(14);
            doc.text(`Valide em: ${qrUrl}`, centerX, y, { align: "center", maxWidth: 700 });
            y += 50;

            // NOTA LEGAL
            doc.setFontSize(18);
            doc.setFont("Times", "bold");
            doc.text("NOTA LEGAL:", centerX, y, { align: "center" });
            y += 30;

            doc.setFontSize(12);
            doc.setFont("Times", "normal");
            const notaLegal = [
              "O certificado √© um documento de comprova√ß√£o da sua atividade cient√≠fica no evento. Sua adultera√ß√£o e uso indevido √© ilegal e est√° sujeita √†s penas da lei.",
              "",
              "Decreto Lei n¬∫ 2.848 de 07 de Dezembro de 1940",
              "",
              "Art. 299 - Omitir, em documento p√∫blico ou particular, declara√ß√£o que dele devia constar, ou nele inserir ou fazer inserir declara√ß√£o falsa ou diversa da que devia ser escrita, com o fim de prejudicar direito, criar obriga√ß√£o ou alterar a verdade sobre fato juridicamente relevante:",
              "",
              "Pena - reclus√£o, de um a cinco anos, e multa, se o documento √© p√∫blico, e reclus√£o de um a tr√™s anos, e multa, se o documento √© particular.",
              "",
              "Par√°grafo √∫nico - Se o agente √© funcion√°rio p√∫blico, e comete o crime prevalecendo-se do cargo, ou se a falsifica√ß√£o ou altera√ß√£o √© de assentamento de registro civil, aumenta-se a pena de sexta parte."
            ];

            notaLegal.forEach((line, i) => {
              if (line.trim() === "") {
                return;
              }
              doc.text(line, centerX, y + i * 15, { align: "center", maxWidth: 700 });
            });

            console.log('üîç CHECKPOINT 11: Salvando arquivo PDF...');

            // Nome do arquivo baseado no template e participante
            const safeName = participantName.replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
            const templateName = certificateData?.template?.metadata?.template || certType || 'certificado';
            const fileName = `${templateName}-${safeName}-${code}.pdf`;

            // Salvar arquivo
            doc.save(fileName);
            
            console.log('üîç CHECKPOINT 12: PDF salvo com sucesso!');
            alert('üéâ PDF gerado com sucesso!');
            
            resolve();

          } catch (error) {
            console.error('üî¥ Erro ao processar imagem e gerar PDF:', error);
            alert('üî¥ Erro ao processar imagem: ' + error.message);
            reject(error);
          }
        };

        img.onerror = () => {
          console.warn('‚ö†Ô∏è N√£o foi poss√≠vel carregar a imagem do certificado, gerando PDF apenas com texto');
          alert('‚ö†Ô∏è Imagem n√£o carregou, gerando PDF simples...');
          
          try {
            // Se n√£o conseguir carregar a imagem, gerar PDF sem ela
            // Gerar PDF apenas com texto
            doc.setFont("Times", "bold");
            doc.setFontSize(24);
            doc.text(templateTitle, 421, 100, { align: "center" });

            const textLines = getDisplayLines();
            let currentY = 150;

            textLines.forEach((line, index) => {
              if (!line || line.trim() === '') return;

              // Definir estilos e espa√ßamento baseado no contexto da linha
              let fontSize, baseSpacing, fontWeight;
              if (index === 0) {
                fontWeight = certificateData.certType === 'PRESENTATION'? "normal": "bold";
                console.log('üî§ img.onerror - certType:', certificateData.certType, 'fontWeight:', fontWeight);

                // Aplicar fonte usando m√©todo mais direto
                if (certificateData.certType === 'PRESENTATION') {
                  doc.setFont("times", "normal");
                } else {
                  doc.setFont("times", "bold");
                }

                fontSize = certificateData.certType === 'PRESENTATION'? 18: 22;
                doc.setFontSize(fontSize);
                baseSpacing = certificateData.certType === 'PRESENTATION'? Math.round(18 * 1.1): 30;
                currentY += baseSpacing;
              } else if (isNameLine(line, index)) {
                doc.setFont("Times", "bold");
                fontSize = 20;
                doc.setFontSize(fontSize);
                baseSpacing = 30;
                currentY += baseSpacing;
              } else {
                doc.setFont("Times", "normal");
                fontSize = 16;
                doc.setFontSize(fontSize);
                baseSpacing = Math.round(16 * 1.1); // Aumento de 10%
                currentY += baseSpacing;
              }

              // Calcular quebras de linha para ajustar espa√ßamento
              const maxWidth = 700;
              const { linesCount, extraSpacing } = calculateTextLines(doc, line, maxWidth, fontSize);

              // Se o texto n√£o quebra, renderizar normalmente
              if (linesCount === 1) {
                doc.text(line, 421, currentY, { align: "center", maxWidth: 700 });
              } else {
                // Se o texto quebra em m√∫ltiplas linhas, renderizar linha por linha com espa√ßamento
                const words = line.split(' ');
                let currentLineText = '';
                let lineIndex = 0;
                const lineSpacing = fontSize * 1.22; // 22% a mais entre linhas quebradas

                words.forEach((word, wordIndex) => {
                  const testLine = currentLineText ? `${currentLineText} ${word}` : word;
                  const testWidth = doc.getTextWidth(testLine);

                  if (testWidth > maxWidth && currentLineText) {
                    // Renderizar a linha atual
                    doc.text(currentLineText, 421, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                    lineIndex++;
                    currentLineText = word;
                  } else {
                    currentLineText = testLine;
                  }

                  // Se √© a √∫ltima palavra, renderizar a linha final
                  if (wordIndex === words.length - 1) {
                    doc.text(currentLineText, 421, currentY + (lineIndex * lineSpacing), {
                      align: "center"
                    });
                  }
                });

                // Ajustar currentY para as linhas adicionais
                currentY += (linesCount - 1) * lineSpacing;
              }

              // Adicionar espa√ßo extra ap√≥s a linha do nome
              if (isNameLine(line, index)) {
                currentY += 20; // Espa√ßo extra ap√≥s o nome
              }
            });

            currentY += 50;
            doc.setFont("Times", "normal");
            doc.setFontSize(12);
            doc.text(`C√≥digo de autentica√ß√£o: ${code}`, 421, currentY, { align: "center" });

            // Adicionar QR Code mesmo sem imagem de fundo
            doc.addImage(qrDataUrl, 'PNG', 371, currentY + 30, 100, 100);

            const safeName = participantName.replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_-]/g, "");
            const templateName = certificateData?.template?.metadata?.template || certType || 'certificado';
            const fileName = `${templateName}-${safeName}-${code}.pdf`;

            doc.save(fileName);
            alert('üéâ PDF simples gerado com sucesso!');
            resolve();

          } catch (error) {
            console.error('üî¥ Erro ao gerar PDF sem imagem:', error);
            alert('üî¥ Erro ao gerar PDF sem imagem: ' + error.message);
            reject(error);
          }
        };
      } catch (qrError) {
        console.error('üî¥ Erro ao gerar QR Code:', qrError);
        alert('üî¥ Erro ao gerar QR Code: ' + qrError.message);
        reject(qrError);
      }
    } catch (error) {
      console.error('üî¥ Erro geral na fun√ß√£o:', error);
      alert('üî¥ Erro geral: ' + error.message);
      reject(error);
    }
  });
}
